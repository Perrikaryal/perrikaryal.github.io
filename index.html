<!doctype html>
<html><head><meta charset=utf-8><title>Twitch Embed</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Twitch embed with latency monitoring for Unity WebView">
<style>
html,body{margin:0;height:100%;width:100%;background:#000;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial,sans-serif;overflow:hidden}
#twitch{position:fixed;inset:0;width:100%;height:100%}
#loading{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;text-align:center;z-index:1000}
.status{position:fixed;top:10px;left:10px;background:rgba(138,43,226,0.95);color:#fff;padding:8px 16px;border-radius:8px;font-size:14px;font-weight:500;z-index:1001;box-shadow:0 4px 12px rgba(0,0,0,0.4);border:1px solid rgba(255,255,255,0.1)}
.success{background:rgba(34,197,94,0.95)!important}
.error{background:rgba(239,68,68,0.95)!important}
.warning{background:rgba(245,158,11,0.95)!important}
.info{background:rgba(59,130,246,0.95)!important}
.spinner{border:3px solid rgba(255,255,255,0.3);border-top:3px solid #fff;border-radius:50%;width:32px;height:32px;animation:spin 1s linear infinite;margin:0 auto 20px}
@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
.latency-display{position:fixed;top:10px;right:10px;background:rgba(0,0,0,0.8);color:#00ff00;padding:6px 12px;border-radius:6px;font-size:12px;font-family:monospace;z-index:1002;border:1px solid rgba(0,255,0,0.3);display:none}
.controls{position:fixed;bottom:10px;left:10px;display:flex;gap:8px;z-index:1003}
.btn{background:rgba(0,0,0,0.8);color:#fff;border:1px solid rgba(255,255,255,0.3);padding:6px 12px;border-radius:6px;font-size:12px;cursor:pointer;transition:all 0.2s}
.btn:hover{background:rgba(255,255,255,0.1);border-color:rgba(255,255,255,0.5)}
.debug-panel{position:fixed;bottom:50px;left:10px;background:rgba(0,0,0,0.9);color:#fff;padding:12px;border-radius:8px;font-size:11px;font-family:monospace;max-width:300px;max-height:200px;overflow-y:auto;display:none;z-index:1004;border:1px solid rgba(255,255,255,0.2)}
@media (max-width: 768px) {
    .status{font-size:12px;padding:6px 12px}
    .controls{bottom:60px;flex-direction:column;gap:4px}
    .btn{font-size:11px;padding:4px 8px}
}
</style>
</head><body>
<div id="loading">
  <div class="spinner"></div>
  <div>Loading Twitch stream...</div>
  <div style="font-size:12px;margin-top:10px;opacity:0.7">GitHub Pages HTTPS</div>
</div>
<div id="status" class="status">üåê Initializing...</div>
<div id="latency" class="latency-display">Latency: --</div>
<div id="twitch"></div>

<div class="controls">
  <button class="btn" onclick="toggleLatencyDisplay()">üìä</button>
  <button class="btn" onclick="toggleDebugPanel()">üîß</button>
  <button class="btn" onclick="refreshStream()">üîÑ</button>
  <button class="btn" onclick="manualMatureBypass()">üé¨</button>
</div>

<div id="debug" class="debug-panel">
  <div id="debug-content">Debug info will appear here...</div>
</div>

<script>
console.log('üåê Twitch GitHub Pages Embed v2.3 - Enhanced with Iframe Interaction');
console.log('üìç URL:', window.location.href);
console.log('üñ•Ô∏è User Agent:', navigator.userAgent);

// Parse URL parameters
const urlParams = new URLSearchParams(window.location.search);
const channel = urlParams.get('channel') || 'Perrikaryal';
const quality = urlParams.get('quality') || '1080p';
const volume = parseFloat(urlParams.get('volume')) || 0.1;
const autoplay = urlParams.get('autoplay') !== 'false';
const muted = urlParams.get('muted') === 'true';
const debug = urlParams.get('debug') === 'true';
const autoBypassMature = urlParams.get('autoBypassMature') !== 'false'; // New parameter

// Configuration
const config = {
    channel: channel,
    quality: quality,
    volume: volume,
    autoplay: autoplay,
    muted: muted,
    debug: debug,
    autoBypassMature: autoBypassMature,
    latencyInterval: 1000,
    latencyTimeout: 5000,
    matureCheckInterval: 100, // Check every 100ms - very aggressive
    maxMatureRetries: 300 // Check for 30 seconds
};

console.log('‚öôÔ∏è Config:', config);

// Global variables
let statusDiv = document.getElementById('status');
let loadingDiv = document.getElementById('loading');
let latencyDiv = document.getElementById('latency');
let debugDiv = document.getElementById('debug');
let debugContent = document.getElementById('debug-content');

let player = null;
let latencyMonitor = null;
let matureContentMonitor = null;
let currentLatency = -1;
let lastLatencyUpdate = 0;
let playerReady = false;
let latencyDisplayVisible = false;
let debugPanelVisible = false;
let matureRetryCount = 0;

// Debug logging
const debugLogs = [];
function debugLog(message) {
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = `[${timestamp}] ${message}`;
    debugLogs.push(logEntry);
    console.log(logEntry);
    
    if (debugPanelVisible && debugContent) {
        debugContent.innerHTML = debugLogs.slice(-20).join('<br>');
        debugContent.scrollTop = debugContent.scrollHeight;
    }
}

// Status management
function updateStatus(msg, type = '') {
    debugLog(`Status: ${msg} (${type})`);
    if (statusDiv) {
        statusDiv.innerHTML = 'üåê ' + msg;
        statusDiv.className = 'status' + (type ? ' ' + type : '');
    }
}

// Mature content bypass function
function attemptMatureContentBypass() {
    if (!config.autoBypassMature) return false;
    
    try {
        debugLog('üîç Searching for mature content elements... (v2.3)');
        
        // First, log the entire DOM structure we can see
        const bodyChildCount = document.body ? document.body.children.length : 0;
        const allDivs = document.querySelectorAll('div').length;
        const allButtons = document.querySelectorAll('button').length;
        const allIframes = document.querySelectorAll('iframe').length;
        
        debugLog(`üìä DOM Stats: ${bodyChildCount} body children, ${allDivs} divs, ${allButtons} buttons, ${allIframes} iframes`);
        
        // Since we confirmed the mature content is in the iframe, let's focus on iframe interaction
        const twitchIframe = document.querySelector('#twitch iframe') || document.querySelector('iframe');
        
        if (twitchIframe) {
            debugLog(`üéØ Found iframe: ${twitchIframe.src || 'no src'}`);
            
            // Method 1: Try to access iframe content (might fail due to CORS)
            try {
                const iframeDoc = twitchIframe.contentDocument || twitchIframe.contentWindow.document;
                if (iframeDoc) {
                    debugLog('‚úÖ Can access iframe content directly!');
                    
                    // Try the exact selectors the user provided
                    const specificSelectors = [
                        '#channel-player-gate > div > div > div.Layout-sc-1xcs6mc-0.dUxMTz > div > button',
                        'button[data-a-target="content-classification-gate-overlay-start-watching-button"]',
                        '#channel-player-gate button',
                        '#channel-player-gate',
                        '[data-a-target="tw-core-button-label-text"]'
                    ];
                    
                    for (const selector of specificSelectors) {
                        const elements = iframeDoc.querySelectorAll(selector);
                        debugLog(`  Iframe selector "${selector}": found ${elements.length} elements`);
                        
                        for (const element of elements) {
                            const text = (element.textContent || element.innerText || '').trim();
                            debugLog(`    Iframe element: ${element.tagName} - "${text}"`);
                            
                            if (text.toLowerCase().includes('start watching') || 
                                selector.includes('content-classification-gate') ||
                                selector.includes('start-watching')) {
                                debugLog(`‚úÖ FOUND TARGET IN IFRAME! Clicking: ${element.tagName}`);
                                element.click();
                                updateStatus('Auto-clicked Start Watching (iframe)', 'success');
                                return true;
                            }
                        }
                    }
                    
                    // Search all elements in iframe
                    const allIframeElements = iframeDoc.querySelectorAll('*');
                    let iframeButtonsFound = 0;
                    
                    for (const element of allIframeElements) {
                        const text = (element.textContent || element.innerText || '').trim();
                        const tagName = element.tagName.toLowerCase();
                        
                        if (tagName === 'button') {
                            iframeButtonsFound++;
                            debugLog(`    Iframe button: "${text.substring(0, 30)}"`);
                        }
                        
                        if (text.toLowerCase().includes('start watching') && element.offsetParent !== null) {
                            debugLog(`üéØ Found "Start Watching" in iframe: ${tagName} - "${text}"`);
                            const clickTarget = element.closest('button') || element;
                            clickTarget.click();
                            updateStatus('Auto-clicked Start Watching (iframe)', 'success');
                            return true;
                        }
                    }
                    
                    debugLog(`üìä Iframe search: ${allIframeElements.length} elements, ${iframeButtonsFound} buttons`);
                }
            } catch (crossOriginError) {
                debugLog(`‚ùå Cannot access iframe content: ${crossOriginError.message}`);
            }
            
            // Method 2: Send PostMessage to iframe
            try {
                debugLog('üì® Sending postMessage to iframe...');
                twitchIframe.contentWindow.postMessage({
                    type: 'CLICK_START_WATCHING',
                    action: 'bypass_mature_content',
                    selectors: [
                        '#channel-player-gate > div > div > div.Layout-sc-1xcs6mc-0.dUxMTz > div > button',
                        'button[data-a-target="content-classification-gate-overlay-start-watching-button"]'
                    ]
                }, '*');
                
                // Also try the Twitch domain specifically
                twitchIframe.contentWindow.postMessage({
                    type: 'CLICK_START_WATCHING',
                    action: 'bypass_mature_content'
                }, 'https://player.twitch.tv');
                
                debugLog('üì® PostMessages sent');
            } catch (postError) {
                debugLog(`‚ùå PostMessage failed: ${postError.message}`);
            }
            
            // Method 3: Simulate clicking on the iframe at likely button positions
            const rect = twitchIframe.getBoundingClientRect();
            const clickPositions = [
                { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 }, // Center
                { x: rect.left + rect.width / 2, y: rect.top + rect.height * 0.6 }, // Lower center
                { x: rect.left + rect.width / 2, y: rect.top + rect.height * 0.7 }, // Even lower
            ];
            
            for (const pos of clickPositions) {
                debugLog(`üñ±Ô∏è Simulating click at iframe position (${pos.x.toFixed(0)}, ${pos.y.toFixed(0)})`);
                
                // Create and dispatch mouse events
                const events = ['mousedown', 'mouseup', 'click'];
                for (const eventType of events) {
                    const event = new MouseEvent(eventType, {
                        clientX: pos.x,
                        clientY: pos.y,
                        bubbles: true,
                        cancelable: true,
                        view: window
                    });
                    
                    // Dispatch on the iframe
                    twitchIframe.dispatchEvent(event);
                    
                    // Also try dispatching on the document at that position
                    const elementAtPosition = document.elementFromPoint(pos.x, pos.y);
                    if (elementAtPosition) {
                        elementAtPosition.dispatchEvent(event);
                    }
                }
            }
            
            // Method 4: Focus iframe and send keyboard events
            try {
                debugLog('‚å®Ô∏è Sending keyboard events to iframe...');
                twitchIframe.focus();
                
                const keyEvents = [
                    { key: 'Enter', code: 'Enter', keyCode: 13 },
                    { key: ' ', code: 'Space', keyCode: 32 },
                    { key: 'Tab', code: 'Tab', keyCode: 9 }
                ];
                
                keyEvents.forEach((keyData, index) => {
                    setTimeout(() => {
                        const keyEvent = new KeyboardEvent('keydown', {
                            key: keyData.key,
                            code: keyData.code,
                            keyCode: keyData.keyCode,
                            bubbles: true,
                            cancelable: true
                        });
                        
                        twitchIframe.dispatchEvent(keyEvent);
                        debugLog(`‚å®Ô∏è Sent ${keyData.key} key to iframe`);
                    }, index * 100);
                });
            } catch (keyError) {
                debugLog(`‚ùå Keyboard events failed: ${keyError.message}`);
            }
            
            debugLog('‚úÖ Attempted all iframe interaction methods');
            return true; // We tried something
        }
        
        // Fallback: Search main document (but we know this won't find it)
        debugLog('üîç Fallback: searching main document...');
        
        const allElements = document.querySelectorAll('*');
        let realStartWatchingFound = 0;
        
        for (const element of allElements) {
            // Skip our own debug elements and HTML/BODY with all content
            if (element.closest && (element.closest('.debug-panel') || 
                element.closest('.controls') || 
                element.closest('.status') ||
                element.closest('.latency-display'))) {
                continue;
            }
            
            if (element.tagName === 'HTML' || element.tagName === 'BODY') {
                continue; // Skip these as they contain all page text
            }
            
            const text = (element.textContent || element.innerText || '').trim();
            
            // Only look for elements that have ONLY "Start Watching" as their text content
            if (text.toLowerCase() === 'start watching' && element.offsetParent !== null) {
                realStartWatchingFound++;
                debugLog(`üéØ Found isolated "Start Watching" text: ${element.tagName}`);
                
                const clickTarget = element.closest('button') || element;
                try {
                    clickTarget.click();
                    updateStatus('Auto-clicked Start Watching (main doc)', 'success');
                    return true;
                } catch (clickError) {
                    debugLog(`‚ùå Click failed: ${clickError.message}`);
                }
            }
        }
        
        debugLog(`üìä Main document: found ${realStartWatchingFound} isolated "Start Watching" elements`);
        
        return false;
    } catch (e) {
        debugLog(`‚ùå Mature content bypass error: ${e.message}`);
        return false;
    }
}

// Start monitoring for mature content warnings
function startMatureContentMonitoring() {
    if (!config.autoBypassMature || matureContentMonitor) return;
    
    debugLog('üîç Starting aggressive mature content monitoring v2.3...');
    matureRetryCount = 0;
    
    // Set up MutationObserver to watch for dynamically added content
    const observer = new MutationObserver((mutations) => {
        let shouldCheck = false;
        
        mutations.forEach((mutation) => {
            if (mutation.type === 'childList') {
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        shouldCheck = true;
                        debugLog(`üîç MutationObserver: New ${node.tagName} added`);
                        
                        // Check the added node immediately
                        const text = (node.textContent || node.innerText || '').trim();
                        if (text.toLowerCase().includes('start watching')) {
                            debugLog(`üéØ MutationObserver found "Start Watching" immediately!`);
                            setTimeout(() => attemptMatureContentBypass(), 50);
                        }
                    }
                });
            }
        });
        
        // If we detected changes, do a full scan
        if (shouldCheck) {
            setTimeout(() => {
                debugLog('üîç MutationObserver triggered full scan');
                if (attemptMatureContentBypass()) {
                    stopMatureContentMonitoring();
                }
            }, 100);
        }
    });
    
    // Start observing the document with the configured parameters
    observer.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['class', 'id', 'data-a-target']
    });
    
    // Also observe the entire document if possible
    try {
        if (window.top && window.top.document && window.top.document !== document) {
            const topObserver = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === Node.ELEMENT_NODE) {
                                const text = (node.textContent || node.innerText || '').trim();
                                if (text.toLowerCase().includes('start watching')) {
                                    debugLog(`üéØ Top-level MutationObserver found "Start Watching"!`);
                                    setTimeout(() => attemptMatureContentBypass(), 50);
                                }
                            }
                        });
                    }
                });
            });
            
            topObserver.observe(window.top.document.body, {
                childList: true,
                subtree: true
            });
            
            window.topMatureContentObserver = topObserver;
            debugLog('üîç Also monitoring top-level document');
        }
    } catch (e) {
        debugLog(`‚ùå Cannot monitor top-level document: ${e.message}`);
    }
    
    // Store observer for cleanup
    window.matureContentObserver = observer;
    
    // Very aggressive periodic check as fallback
    matureContentMonitor = setInterval(() => {
        if (matureRetryCount >= config.maxMatureRetries) {
            clearInterval(matureContentMonitor);
            matureContentMonitor = null;
            if (window.matureContentObserver) {
                window.matureContentObserver.disconnect();
                window.matureContentObserver = null;
            }
            if (window.topMatureContentObserver) {
                window.topMatureContentObserver.disconnect();
                window.topMatureContentObserver = null;
            }
            debugLog('‚è∞ Mature content monitoring timeout - stopping');
            return;
        }
        
        matureRetryCount++;
        
        // Log progress every 50 attempts (5 seconds)
        if (matureRetryCount % 50 === 0) {
            debugLog(`üîç Mature content monitoring: attempt ${matureRetryCount}/${config.maxMatureRetries}`);
        }
        
        if (attemptMatureContentBypass()) {
            clearInterval(matureContentMonitor);
            matureContentMonitor = null;
            if (window.matureContentObserver) {
                window.matureContentObserver.disconnect();
                window.matureContentObserver = null;
            }
            if (window.topMatureContentObserver) {
                window.topMatureContentObserver.disconnect();
                window.topMatureContentObserver = null;
            }
            debugLog('‚úÖ Mature content bypass successful - stopping monitoring');
        }
    }, config.matureCheckInterval);
}

// Stop mature content monitoring
function stopMatureContentMonitoring() {
    if (matureContentMonitor) {
        clearInterval(matureContentMonitor);
        matureContentMonitor = null;
        debugLog('üõë Stopped mature content monitoring');
    }
    
    if (window.matureContentObserver) {
        window.matureContentObserver.disconnect();
        window.matureContentObserver = null;
        debugLog('üõë Stopped MutationObserver');
    }
    
    if (window.topMatureContentObserver) {
        window.topMatureContentObserver.disconnect();
        window.topMatureContentObserver = null;
        debugLog('üõë Stopped top-level MutationObserver');
    }
}

// Latency display
function updateLatencyDisplay(latency) {
    if (latencyDiv) {
        if (latency >= 0) {
            latencyDiv.innerHTML = `Latency: ${latency.toFixed(2)}s`;
            latencyDiv.style.color = latency < 3 ? '#00ff00' : latency < 6 ? '#ffff00' : '#ff6666';
        } else {
            latencyDiv.innerHTML = 'Latency: --';
            latencyDiv.style.color = '#666';
        }
    }
}

// Control functions
function toggleLatencyDisplay() {
    latencyDisplayVisible = !latencyDisplayVisible;
    if (latencyDiv) {
        latencyDiv.style.display = latencyDisplayVisible ? 'block' : 'none';
    }
    debugLog(`Latency display: ${latencyDisplayVisible ? 'shown' : 'hidden'}`);
}

function toggleDebugPanel() {
    debugPanelVisible = !debugPanelVisible;
    if (debugDiv) {
        debugDiv.style.display = debugPanelVisible ? 'block' : 'none';
        if (debugPanelVisible && debugContent) {
            debugContent.innerHTML = debugLogs.slice(-20).join('<br>');
            debugContent.scrollTop = debugContent.scrollHeight;
        }
    }
    debugLog(`Debug panel: ${debugPanelVisible ? 'shown' : 'hidden'}`);
}

function refreshStream() {
    debugLog('Refreshing stream...');
    if (player) {
        try {
            player.pause();
            setTimeout(() => {
                if (player) {
                    player.play();
                    // Restart mature content monitoring after refresh
                    setTimeout(() => startMatureContentMonitoring(), 2000);
                }
            }, 500);
            updateStatus('Stream refreshed', 'info');
        } catch (e) {
            debugLog(`Refresh error: ${e.message}`);
            updateStatus('Refresh failed', 'error');
        }
    }
}

function manualMatureBypass() {
    debugLog('Manual mature content bypass triggered...');
    updateStatus('Manual bypass attempt...', 'info');
    
    if (attemptMatureContentBypass()) {
        updateStatus('Manual bypass successful!', 'success');
    } else {
        updateStatus('No mature content found', 'warning');
    }
}

// Unity communication
window.getLatency = function() {
    return currentLatency;
};

window.getPlayerState = function() {
    if (!player || !playerReady) return 'not_ready';
    try {
        if (player.isPaused()) return 'paused';
        if (player.getEnded()) return 'ended';
        return 'playing';
    } catch (e) {
        return 'error';
    }
};

window.setVolume = function(vol) {
    if (player && playerReady) {
        try {
            player.setVolume(Math.max(0, Math.min(1, vol)));
            debugLog(`Volume set to: ${vol}`);
            return true;
        } catch (e) {
            debugLog(`Volume error: ${e.message}`);
            return false;
        }
    }
    return false;
};

window.setQuality = function(qual) {
    if (player && playerReady) {
        try {
            const qualities = player.getQualities();
            const target = qualities.find(q => 
                q.name && q.name.toLowerCase().includes(qual.toLowerCase())
            ) || qualities.find(q => q.name === 'auto') || qualities[0];
            
            if (target) {
                player.setQuality(target.group || target.name);
                debugLog(`Quality set to: ${target.name}`);
                return true;
            }
        } catch (e) {
            debugLog(`Quality error: ${e.message}`);
        }
    }
    return false;
};

window.playPause = function() {
    if (player && playerReady) {
        try {
            if (player.isPaused()) {
                player.play();
                debugLog('Player resumed');
                return 'playing';
            } else {
                player.pause();
                debugLog('Player paused');
                return 'paused';
            }
        } catch (e) {
            debugLog(`Play/pause error: ${e.message}`);
            return 'error';
        }
    }
    return 'not_ready';
};

// Unity message handling
window.addEventListener('unitydata', function(e) {
    debugLog(`Unity message: ${e.detail}`);
    
    if (e.detail === 'getLatency' && typeof window.sendToUnity === 'function') {
        try {
            window.sendToUnity('lat:' + currentLatency);
        } catch (err) {
            debugLog(`Unity latency response error: ${err.message}`);
            window.sendToUnity('lat:-1');
        }
    } else if (e.detail === 'getState' && typeof window.sendToUnity === 'function') {
        try {
            window.sendToUnity('state:' + window.getPlayerState());
        } catch (err) {
            window.sendToUnity('state:error');
        }
    } else if (e.detail.startsWith('setVolume:') && typeof window.sendToUnity === 'function') {
        const vol = parseFloat(e.detail.substring(10));
        const success = window.setVolume(vol);
        window.sendToUnity('volume:' + (success ? 'ok' : 'error'));
    } else if (e.detail.startsWith('setQuality:') && typeof window.sendToUnity === 'function') {
        const qual = e.detail.substring(11);
        const success = window.setQuality(qual);
        window.sendToUnity('quality:' + (success ? 'ok' : 'error'));
    } else if (e.detail === 'playPause' && typeof window.sendToUnity === 'function') {
        const state = window.playPause();
        window.sendToUnity('playPause:' + state);
    }
});

// Listen for postMessage responses from iframe
window.addEventListener('message', function(event) {
    debugLog(`üì® Received postMessage: ${JSON.stringify(event.data)} from ${event.origin}`);
    
    if (event.data && event.data.type === 'MATURE_CONTENT_CLICKED') {
        debugLog('‚úÖ Iframe confirmed mature content button was clicked!');
        updateStatus('Iframe clicked Start Watching', 'success');
        stopMatureContentMonitoring();
    } else if (event.data && event.data.type === 'MATURE_CONTENT_NOT_FOUND') {
        debugLog('‚ùå Iframe could not find mature content button');
    }
});

// Latency monitoring
function startLatencyMonitoring() {
    if (latencyMonitor) clearInterval(latencyMonitor);
    
    latencyMonitor = setInterval(() => {
        if (!player || !playerReady) {
            currentLatency = -1;
            updateLatencyDisplay(currentLatency);
            return;
        }
        
        try {
            const stats = player.getPlaybackStats();
            if (stats && typeof stats.hlsLatencyBroadcaster !== 'undefined') {
                currentLatency = stats.hlsLatencyBroadcaster;
                lastLatencyUpdate = Date.now();
                updateLatencyDisplay(currentLatency);
                
                // Send to Unity if available
                if (typeof window.sendToUnity === 'function') {
                    try {
                        window.sendToUnity('latency:' + currentLatency);
                    } catch (e) {
                        // Silent fail - Unity might not be listening
                    }
                }
            } else {
                // Check if data is stale
                if (Date.now() - lastLatencyUpdate > config.latencyTimeout) {
                    currentLatency = -1;
                    updateLatencyDisplay(currentLatency);
                }
            }
        } catch (e) {
            debugLog(`Latency monitoring error: ${e.message}`);
            currentLatency = -1;
            updateLatencyDisplay(currentLatency);
        }
    }, config.latencyInterval);
    
    debugLog('Latency monitoring started');
}

function stopLatencyMonitoring() {
    if (latencyMonitor) {
        clearInterval(latencyMonitor);
        latencyMonitor = null;
        currentLatency = -1;
        updateLatencyDisplay(currentLatency);
        debugLog('Latency monitoring stopped');
    }
}

// Initialize Twitch player
function initializeTwitchPlayer() {
    debugLog('Initializing Twitch player...');
    updateStatus('Creating Twitch player...', '');
    
    try {
        player = new Twitch.Player('twitch', {
            channel: config.channel,
            quality: 'auto',
            width: '100%',
            height: '100%',
            autoplay: config.autoplay,
            muted: config.muted,
            volume: config.volume,
            parent: [window.location.hostname],
            allowfullscreen: false
        });
        
        updateStatus('Player created, waiting for ready...', 'info');
        debugLog(`Player config: channel=${config.channel}, quality=auto, volume=${config.volume}, autoplay=${config.autoplay}, muted=${config.muted}`);
        
        // Event listeners
        player.addEventListener(Twitch.Player.READY, function() {
            debugLog('üéâ Twitch player ready!');
            playerReady = true;
            updateStatus('Player ready!', 'success');
            if (loadingDiv) loadingDiv.style.display = 'none';
            
            // Start mature content monitoring immediately when player is ready
            startMatureContentMonitoring();
            
            // Start latency monitoring
            startLatencyMonitoring();
            
            // Set initial quality after a delay
            setTimeout(() => {
                try {
                    const qualities = player.getQualities();
                    debugLog(`Available qualities: ${qualities.map(q => q.name).join(', ')}`);
                    
                    const targetQuality = config.quality;
                    const matchedQuality = qualities.find(q => 
                        q.name && q.name.toLowerCase().includes(targetQuality.toLowerCase())
                    ) || qualities.find(q => q.name === 'auto') || qualities[0];
                    
                    if (matchedQuality) {
                        player.setQuality(matchedQuality.group || matchedQuality.name);
                        debugLog(`Quality set to: ${matchedQuality.name}`);
                        updateStatus(`üéÆ ${matchedQuality.name}`, 'success');
                        
                        // Show latency display if debug mode
                        if (config.debug) {
                            toggleLatencyDisplay();
                            toggleDebugPanel();
                        }
                    }
                } catch (e) {
                    debugLog(`Quality setting error: ${e.message}`);
                    updateStatus('Quality setting failed', 'warning');
                }
            }, 2000);
        });

        player.addEventListener(Twitch.Player.PLAYING, function() {
            debugLog('‚ñ∂Ô∏è Stream playing');
            updateStatus('üéÆ Playing', 'success');
            // Stop mature content monitoring once playing
            stopMatureContentMonitoring();
        });

        player.addEventListener(Twitch.Player.PAUSE, function() {
            debugLog('‚è∏Ô∏è Stream paused');
            updateStatus('‚è∏Ô∏è Paused', 'warning');
        });

        player.addEventListener(Twitch.Player.ENDED, function() {
            debugLog('üèÅ Stream ended');
            updateStatus('Stream ended', 'info');
            stopLatencyMonitoring();
            stopMatureContentMonitoring();
        });

        player.addEventListener(Twitch.Player.OFFLINE, function() {
            debugLog('üì∫ Stream offline');
            updateStatus('üì∫ Stream offline', 'warning');
            stopLatencyMonitoring();
            stopMatureContentMonitoring();
        });

        // Send ready signal to Unity
        if (typeof window.sendToUnity === 'function') {
            try {
                window.sendToUnity('ready');
            } catch (e) {
                debugLog(`Unity ready signal error: ${e.message}`);
            }
        }

    } catch (e) {
        debugLog(`‚ùå Player initialization error: ${e.message}`);
        updateStatus(`Player creation failed: ${e.message}`, 'error');
        if (loadingDiv) {
            loadingDiv.innerHTML = `<div style="color:#ff6b6b">‚ùå Failed to create player<br><small>${e.message}</small></div>`;
        }
    }
}

// Load Twitch SDK
debugLog('Loading Twitch SDK...');
updateStatus('Loading Twitch SDK...', '');

const script = document.createElement('script');
script.src = 'https://player.twitch.tv/js/embed/v1.js';
script.onload = function() {
    debugLog('‚úÖ Twitch SDK loaded successfully');
    updateStatus('SDK loaded, creating player...', 'info');
    initializeTwitchPlayer();
};
script.onerror = function() {
    debugLog('‚ùå Failed to load Twitch SDK');
    updateStatus('Failed to load Twitch SDK', 'error');
    if (loadingDiv) {
        loadingDiv.innerHTML = '<div style="color:#ff6b6b">‚ùå Failed to load Twitch SDK<br><small>Check internet connection</small></div>';
    }
};
document.head.appendChild(script);

// Global error handling
window.addEventListener('error', function(e) {
    const errorMsg = e.error ? e.error.message : e.message;
    debugLog(`üö® Global error: ${errorMsg} (${e.filename}:${e.lineno})`);
    updateStatus(`Error: ${errorMsg}`, 'error');
});

window.addEventListener('unhandledrejection', function(e) {
    debugLog(`üö® Unhandled promise rejection: ${e.reason}`);
    updateStatus(`Promise error: ${e.reason}`, 'error');
});

// Hide status after successful loading
setTimeout(() => {
    if (statusDiv && statusDiv.textContent.includes('üéÆ') && !config.debug) {
        statusDiv.style.transition = 'opacity 1s';
        statusDiv.style.opacity = '0.3';
        setTimeout(() => {
            if (statusDiv && statusDiv.textContent.includes('üéÆ') && !config.debug) {
                statusDiv.style.display = 'none';
            }
        }, 3000);
    }
}, 8000);

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    stopLatencyMonitoring();
    stopMatureContentMonitoring();
    if (player) {
        try {
            player.pause();
        } catch (e) {
            // Silent cleanup
        }
    }
});

debugLog('üåê GitHub Pages Twitch embed initialized with mature content bypass v2.3');
</script></body></html>
